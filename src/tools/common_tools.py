from typing import Literal
from langchain.tools import tool, ToolRuntime
from langchain_core.messages import BaseMessage
from db import CACHED_AGENTS_MESSAGES
from src.utils.message import combine_ai_messages
from src.context import Context
from src.utils.constants import MAX_TICKERS_ALLOWED

from src.tools_adaptors import (
    GetUserInvestmentStrategyAct,
    WriteInvestmentReportEmailAct,
    SendInvestmentReportEmailAct,
    GetHistoricalReviewedTickersAct,
    GetAnalystAnalysisAct,
    WriteDownSelectedTickersAct,
    GetSelectedTickersAct,
)


get_user_investment_strategy_act = GetUserInvestmentStrategyAct()
send_investment_report_email_act = SendInvestmentReportEmailAct()
write_investment_report_email_act = WriteInvestmentReportEmailAct()
get_historical_reviewed_tickers_act = GetHistoricalReviewedTickersAct()
get_analyst_analysis_act = GetAnalystAnalysisAct()
write_down_selected_tickers_act = WriteDownSelectedTickersAct()
get_selected_tickers_act = GetSelectedTickersAct()


@tool("get_user_investment_strategy")
async def get_user_investment_strategy(runtime: ToolRuntime[Context]):
    """
    Retrieve the current investment strategy for the trading portfolio.

    This tool fetches the current investment strategy for the trading portfolio.

    Possible tool purposes:
    - Allow you to decide which assets or sectors to trade based on the user’s stated risk tolerance or philosophy.
    - Allow you to decide which analysts to heavily use for the investment strategy.
    - Surface the strategy to a dashboard or chat interface so the user can confirm or update it before orders are placed.
    - Act as a guard-rail that prevents trades violating the strategy (e.g., no crypto for a “dividend-income” strategy).

    Returns
    -------
    Investment Strategy
        A string representing the current investment strategy for the trading portfolio.
    """
    return await get_user_investment_strategy_act.arun(runtime.context.bot.id)


@tool(write_investment_report_email_act.name)
async def write_summary_report(runtime: ToolRuntime[Context]):
    """
    Write the final investment report email for the current trading run.
    """
    states = runtime.state
    messages: list[BaseMessage] = states["messages"]  # type: ignore
    conversation = combine_ai_messages(messages)
    context = runtime.context
    await write_investment_report_email_act.arun(
        llm_model=context.llm_model,
        botId=context.bot.id,
        run_id=context.run.id,
        conversation=conversation,
    )

    return "Email written successfully."


@tool(send_investment_report_email_act.name)
async def send_summary_email_tool(runtime: ToolRuntime[Context]):
    """
    Send the final investment report email for the current trading run.
    """
    context = runtime.context
    return await send_investment_report_email_act.arun(
        run_id=context.run.id,
        user_id=context.bot.userId,
        bot_name=context.bot.name,
    )


@tool(get_historical_reviewed_tickers_act.name)
async def get_historical_reviewed_tickers(runtime: ToolRuntime[Context]):
    """
    Get the latest 7 analysis's tickers that have been reviewed for avoiding reviewing the same tickers again.
    """
    return await get_historical_reviewed_tickers_act.arun(runtime.context.bot.id)


@tool(get_analyst_analysis_act.name)
async def get_analyst_analysis(
    role: Literal["MARKET_ANALYST", "EQUITY_RESEARCH_ANALYST"],
    runtime: ToolRuntime[Context],
):
    """
    Retrieve the analysis generated by a specific analyst role to provide a comprehensive view of the analyst's findings and insights.

    Use this tool to:
    - Access the research and analysis performed by other agents (e.g., Market Analyst, Equity Research Analyst).
    - Incorporate findings from different perspectives (macro, fundamental, etc.) into your decision-making process.
    - Ensure your actions are aligned with the broader analysis conducted during the current session.

    """
    return await get_analyst_analysis_act.arun(
        role=role,
        run_id=runtime.context.run.id,
    )


@tool("get_market_deep_research_analysis")
async def get_market_deep_research_analysis():
    """
    Retrieve the deep market research analysis generated by the Market Analyst agent to provide a comprehensive view of macro-level findings and insights.

    Use this tool to:
    - Access the broad market research and macro analysis performed by the Market Analyst.
    - Incorporate macroeconomic, sector, and market-wide perspectives into your decision-making process.
    - Ensure your actions are aligned with the overarching market analysis conducted during the current session.
    """

    content = "Market Analysis Result is not available. Please wait for the Market Analyst to generate the analysis."
    for agent_message in CACHED_AGENTS_MESSAGES:
        langchain_serialized_msg = agent_message["messages"]
        msg_type = langchain_serialized_msg.get("type")
        name = langchain_serialized_msg.get("name")
        if msg_type == "tool" and name == "handoff_to_market_analyst":
            content = langchain_serialized_msg.get("content")
            return content
    return content


@tool(write_down_selected_tickers_act.name)
async def write_down_selected_tickers(
    tickers: list[str],
    runtime: ToolRuntime[Context],
):
    """Write down the selected tickers.

    Args:
        tickers: List of tickers to review
    """
    if len(tickers) > MAX_TICKERS_ALLOWED:
        return f"Only {MAX_TICKERS_ALLOWED} tickers are allowed at a time.Please choose at most {MAX_TICKERS_ALLOWED} tickers."

    runId = runtime.context.run.id
    return await write_down_selected_tickers_act.arun(
        run_id=runId,
        tickers=tickers,
    )


@tool(get_selected_tickers_act.name)
async def get_selected_tickers(
    runtime: ToolRuntime[Context],
):
    """Get the selected tickers to verify if the tickers (equity) have been already selected by the user or equity selection analyst.

    call this tool to verify if the tickers have been already selected by the user or equity selection analyst.
    If the tickers have been already selected, skip the tickers selection process.
    Returns:
        List of selected tickers
    """
    runId = runtime.context.run.id
    return await get_selected_tickers_act.arun(
        run_id=runId,
    )
